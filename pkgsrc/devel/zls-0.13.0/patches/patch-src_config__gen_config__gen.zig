$NetBSD$

--- src/config_gen/config_gen.zig.orig	2024-06-09 00:05:07.000000000 +0000
+++ src/config_gen/config_gen.zig
@@ -225,7 +225,7 @@ fn generateVSCodeConfigFile(allocator: s
         configuration.map.deinit(allocator);
     }
 
-    configuration.map.putAssumeCapacityNoClobber("zig.zls.debugLog", .{
+    configuration.map.putAssumeCapacityNoClobber("zig.zls.trace.server", .{
         .scope = "resource",
         .type = "boolean",
         .description = "Enable debug logging in release builds of ZLS.",
@@ -243,13 +243,16 @@ fn generateVSCodeConfigFile(allocator: s
         .default = .{ .bool = true },
     });
     configuration.map.putAssumeCapacityNoClobber("zig.zls.path", .{
+        .scope = "machine-overridable",
         .type = "string",
-        .description = "Path to `zls` executable. Example: `C:/zls/zig-cache/bin/zls.exe`.",
+        .description = "Path to `zls` executable. Example: `C:/zls/zig-cache/bin/zls.exe`. The string \"zls\" means lookup ZLS in PATH.",
         .format = "path",
         .default = null,
     });
 
     for (config.options) |option| {
+        if (std.mem.eql(u8, option.name, "zig_exe_path")) continue;
+
         const snake_case_name = try std.fmt.allocPrint(allocator, "zig.zls.{s}", .{option.name});
         defer allocator.free(snake_case_name);
         const name = try snakeCaseToCamelCase(allocator, snake_case_name);
@@ -270,7 +273,7 @@ fn generateVSCodeConfigFile(allocator: s
     const writer = buffered_writer.writer();
 
     try std.json.stringify(configuration, .{
-        .whitespace = .indent_4,
+        .whitespace = .indent_2,
         .emit_null_optional_fields = false,
     }, writer);
 
@@ -820,30 +823,9 @@ fn extractSnippetFromSignature(allocator
 
 /// Generates data files from the Zig language Reference (https://ziglang.org/documentation/master/)
 /// Output example: https://github.com/zigtools/zls/blob/0.11.0/src/data/master.zig
-fn generateVersionDataFile(allocator: std.mem.Allocator, version: []const u8, output_path: []const u8, langref_path: ?[]const u8) !void {
+fn generateVersionDataFile(allocator: std.mem.Allocator, version: []const u8, output_path: []const u8, langref_path: []const u8) !void {
     // const langref_source: []const u8 = @embedFile("langref.html.in");
-    const langref_source = blk: {
-        if (langref_path) |path| {
-            const file = try std.fs.cwd().openFile(path, .{});
-            defer file.close();
-            break :blk try file.readToEndAlloc(allocator, std.math.maxInt(usize));
-        } else {
-            const url = try std.fmt.allocPrint(allocator, "https://raw.githubusercontent.com/ziglang/zig/{s}/doc/langref.html.in", .{version});
-            defer allocator.free(url);
-            const response = httpGET(allocator, try std.Uri.parse(url)) catch |err| {
-                std.log.err("failed to download {s}: {}", .{ url, err });
-                return error.DownloadFailed;
-            };
-            break :blk switch (response) {
-                .success => |response_bytes| response_bytes,
-                .other => |status| {
-                    const error_name = status.phrase() orelse @tagName(status.class());
-                    std.log.err("failed to download {s}: {s}", .{ url, error_name });
-                    return error.DownloadFailed;
-                },
-            };
-        }
-    };
+    const langref_source = try std.fs.cwd().readFileAlloc(allocator, langref_path, std.math.maxInt(usize));
     defer allocator.free(langref_source);
 
     const builtins = try collectBuiltinData(allocator, version, langref_source);
@@ -860,22 +842,21 @@ fn generateVersionDataFile(allocator: st
     var buffered_writer = std.io.bufferedWriter(builtin_file.writer());
     var writer = buffered_writer.writer();
 
-    try writer.print(
+    try writer.writeAll(
         \\//! DO NOT EDIT
-        \\//! If you want to specify the zig version, use `zig build -Ddata_version={s}`
         \\//! GENERATED BY src/config_gen/config_gen.zig
         \\
-        \\const Builtin = struct {{
+        \\const Builtin = struct {
         \\    name: []const u8,
         \\    signature: []const u8,
         \\    snippet: []const u8,
         \\    documentation: []const u8,
         \\    arguments: []const []const u8,
-        \\}};
+        \\};
         \\
-        \\pub const builtins = [_]Builtin{{
+        \\pub const builtins = [_]Builtin{
         \\
-    , .{version});
+    );
 
     for (builtins) |builtin| {
         const signature = try std.mem.replaceOwned(u8, allocator, builtin.signature, "\n", "");
@@ -939,43 +920,6 @@ fn generateVersionDataFile(allocator: st
     try buffered_writer.flush();
 }
 
-const Response = union(enum) {
-    success: []const u8,
-    other: std.http.Status,
-};
-
-fn httpGET(allocator: std.mem.Allocator, uri: std.Uri) !Response {
-    var arena_allocator = std.heap.ArenaAllocator.init(allocator);
-    defer arena_allocator.deinit();
-
-    var client = std.http.Client{ .allocator = allocator };
-    defer client.deinit();
-    try client.initDefaultProxies(arena_allocator.allocator());
-
-    var server_header_buffer: [16 * 1024]u8 = undefined;
-
-    var request = try client.open(
-        .GET,
-        uri,
-        .{ .server_header_buffer = &server_header_buffer },
-    );
-    defer request.deinit();
-
-    try request.send();
-    try request.finish();
-    try request.wait();
-
-    if (request.response.status.class() != .success) {
-        return .{
-            .other = request.response.status,
-        };
-    }
-
-    return .{
-        .success = try request.reader().readAllAlloc(allocator, std.math.maxInt(usize)),
-    };
-}
-
 pub fn main() !void {
     var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
     defer std.debug.assert(general_purpose_allocator.deinit() == .ok);
@@ -986,31 +930,29 @@ pub fn main() !void {
     var args_it = try std.process.argsWithAllocator(gpa);
     defer args_it.deinit();
 
-    _ = args_it.next() orelse @panic("");
+    _ = args_it.skip();
 
     var readme_path: ?[]const u8 = null;
     var config_path: ?[]const u8 = null;
     var schema_path: ?[]const u8 = null;
     var vscode_config_path: ?[]const u8 = null;
-    var data_version: ?[]const u8 = null;
-    var data_path: ?[]const u8 = null;
+    var version_data_path: ?[]const u8 = null;
     var langref_path: ?[]const u8 = null;
+    var langref_version: ?[]const u8 = null;
 
     while (args_it.next()) |argname| {
         if (std.mem.eql(u8, argname, "--help")) {
-            try stderr.writeAll(
-                \\ Usage: zig build gen -- [command]
-                \\
-                \\    Commands:
+            try std.io.getStdOut().writeAll(
+                \\Usage: zig build gen -- [command]
                 \\
-                \\    --help                               Prints this message
-                \\    --readme-path [path]                 Update readme file (see README.md)
-                \\    --vscode-config-path [path]          Output zls-vscode configurations 
-                \\    --generate-config-path [path]        Output path to config file (see src/Config.zig)
-                \\    --generate-schema-path [path]        Output json schema file (see schema.json)
-                \\    --generate-version-data [version]    Specify version of data file
-                \\    --generate-version-data-path [path]  Output data file
-                \\    --langref_path [path]                Input langref file (default: fetch from https://raw.githubusercontent.com/ziglang/zig/{[default_data_version]s}/doc/langref.html.in)
+                \\Commands:
+                \\  --help                           Prints this message
+                \\  --generate-vscode-config [path]  Output zls-vscode configurations
+                \\  --generate-config [path]         Output path to config file (see src/Config.zig)
+                \\  --generate-schema [path]         Output json schema file (see schema.json)
+                \\  --generate-version-data [path]   Output data file
+                \\  --langref-path [path]            Input langref.html.in file path
+                \\  --langref-version [version]      Input langref.html.in version
                 \\
             );
         } else if (std.mem.eql(u8, argname, "--readme-path")) {
@@ -1018,45 +960,46 @@ pub fn main() !void {
                 try stderr.print("Expected file path after --readme-path argument.\n", .{});
                 return;
             };
-        } else if (std.mem.eql(u8, argname, "--generate-config-path")) {
+            return std.process.cleanExit();
+        } else if (std.mem.eql(u8, argname, "--generate-config")) {
             config_path = args_it.next() orelse {
-                try stderr.print("Expected output path after --generate-config-path argument.\n", .{});
+                try stderr.print("Expected output path after --generate-config argument.\n", .{});
                 return;
             };
-        } else if (std.mem.eql(u8, argname, "--generate-schema-path")) {
+        } else if (std.mem.eql(u8, argname, "--generate-schema")) {
             schema_path = args_it.next() orelse {
-                try stderr.print("Expected output path after --generate-schema-path argument.\n", .{});
+                try stderr.print("Expected output path after --generate-schema argument.\n", .{});
                 return;
             };
-        } else if (std.mem.eql(u8, argname, "--vscode-config-path")) {
+        } else if (std.mem.eql(u8, argname, "--generate-vscode-config")) {
             vscode_config_path = args_it.next() orelse {
-                try stderr.print("Expected output path after --vscode-config-path argument.\n", .{});
+                try stderr.print("Expected output path after --generate-vscode-config argument.\n", .{});
                 return;
             };
         } else if (std.mem.eql(u8, argname, "--generate-version-data")) {
-            data_version = args_it.next() orelse {
-                try stderr.print("Expected version after --generate-version-data argument.\n", .{});
+            version_data_path = args_it.next() orelse {
+                try stderr.print("Expected output path after --generate-version-data argument.\n", .{});
+                return;
+            };
+        } else if (std.mem.eql(u8, argname, "--langref-path")) {
+            langref_path = args_it.next() orelse {
+                try stderr.print("Expected output path after --langref-path argument.\n", .{});
+                return;
+            };
+        } else if (std.mem.eql(u8, argname, "--langref-version")) {
+            langref_version = args_it.next() orelse {
+                try stderr.print("Expected version after --langref-version argument.\n", .{});
                 return;
             };
             const is_valid_version = blk: {
-                if (std.mem.eql(u8, data_version.?, "master")) break :blk true;
-                _ = std.SemanticVersion.parse(data_version.?) catch break :blk false;
+                if (std.mem.eql(u8, langref_version.?, "master")) break :blk true;
+                _ = std.SemanticVersion.parse(langref_version.?) catch break :blk false;
                 break :blk true;
             };
             if (!is_valid_version) {
-                try stderr.print("'{s}' is not a valid argument after --generate-version-data.\n", .{data_version.?});
+                try stderr.print("'{s}' is not a valid argument after --langref-version.\n", .{langref_version.?});
                 return;
             }
-        } else if (std.mem.eql(u8, argname, "--generate-version-data-path")) {
-            data_path = args_it.next() orelse {
-                try stderr.print("Expected output path after --generate-version-data-path argument.\n", .{});
-                return;
-            };
-        } else if (std.mem.eql(u8, argname, "--langref_path")) {
-            langref_path = args_it.next() orelse {
-                try stderr.print("Expected output path after --langref_path argument.\n", .{});
-                return;
-            };
         } else {
             try stderr.print("Unrecognized argument '{s}'.\n", .{argname});
             return;
@@ -1084,12 +1027,12 @@ pub fn main() !void {
             \\
         );
     }
-    if (data_path) |output_path| {
-        if (data_version) |version| {
-            try generateVersionDataFile(gpa, version, output_path, langref_path);
-        } else {
-            try stderr.writeAll("--generate-version-data-path requires --generate-version-data to be specified");
-            return;
-        }
+    if (version_data_path) |output_path| {
+        try generateVersionDataFile(
+            gpa,
+            langref_version orelse return try stderr.writeAll("--generate-version-data requires --langref-version to be specified"),
+            output_path,
+            langref_path orelse return try stderr.writeAll("--generate-version-data requires --langref-path to be specified"),
+        );
     }
 }
